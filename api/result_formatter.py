"""
Result Formatter and Saver
Handles formatting and saving RAG pipeline results in various formats (HTML, MD, etc.)
"""

import os
import datetime
from typing import Dict, Optional
import markdown


class ResultFormatter:
    """
    Formats and saves RAG pipeline results in various formats.
    """
    
    def __init__(self, output_dir: str = "results"):
        """
        Initialize the result formatter.
        
        Args:
            output_dir (str): Directory to save results
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    def save_result_as_markdown(self, result: Dict, filename: Optional[str] = None) -> str:
        """
        Save RAG result as a Markdown file.
        
        Args:
            result (Dict): RAG pipeline result
            filename (str, optional): Custom filename
        
        Returns:
            str: Path to saved file
        """
        if not filename:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"rag_result_{timestamp}.md"
        
        filepath = os.path.join(self.output_dir, filename)
        
        # Create markdown content
        markdown_content = self._format_result_as_markdown(result)
        
        # Save to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        return filepath
    
    def save_result_as_html(self, result: Dict, filename: Optional[str] = None) -> str:
        """
        Save RAG result as an HTML file.
        
        Args:
            result (Dict): RAG pipeline result
            filename (str, optional): Custom filename
        
        Returns:
            str: Path to saved file
        """
        if not filename:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"rag_result_{timestamp}.html"
        
        filepath = os.path.join(self.output_dir, filename)
        
        # Create HTML content
        html_content = self._format_result_as_html(result)
        
        # Save to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return filepath
    
    def _format_result_as_markdown(self, result: Dict) -> str:
        """
        Format RAG result as Markdown content.
        
        Args:
            result (Dict): RAG pipeline result
        
        Returns:
            str: Formatted Markdown content
        """
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        md_content = f"""# RAG Pipeline Result

**Generated:** {timestamp}

## Query
{result.get('query', 'N/A')}

## Answer
{result.get('answer', 'No answer available')}

## Metadata
- **Confidence:** {result.get('confidence', 0):.2f}
- **LLM Model:** {result.get('llm_model', 'N/A')}
- **LLM Available:** {'Yes' if result.get('llm_available') else 'No'}
- **Tokens Used:** {result.get('tokens_used', 'N/A')}
- **Session ID:** {result.get('session_id', 'N/A')}
- **Context Used:** {result.get('context_used', 'N/A')} characters

"""

        # Add sources if available
        sources = result.get('sources', [])
        if sources:
            md_content += "## Sources\n\n"
            for i, source in enumerate(sources, 1):
                source_url = source.get('source_url', 'Unknown')
                md_content += f"{i}. [{source_url}]({source_url})\n"
            md_content += "\n"
        
        # Add search results if available
        search_results = result.get('search_results', [])
        if search_results:
            md_content += "## Search Results\n\n"
            for i, search_result in enumerate(search_results[:3], 1):  # Top 3
                score = search_result.get('similarity_score', 0)
                chunk = search_result.get('chunk', 'No content')[:200]
                md_content += f"### Result {i} (Score: {score:.3f})\n"
                md_content += f"> {chunk}...\n\n"
        
        # Add context if available and no LLM
        if not result.get('llm_available') and result.get('context'):
            md_content += "## Retrieved Context\n\n"
            context = result.get('context', '')[:1000]
            md_content += f"```\n{context}...\n```\n\n"
        
        md_content += "---\n*Generated by RAG Pipeline*"
        
        return md_content
    
    def _format_result_as_html(self, result: Dict) -> str:
        """
        Format RAG result as HTML content.
        
        Args:
            result (Dict): RAG pipeline result
        
        Returns:
            str: Formatted HTML content
        """
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # If markdown library is available, convert markdown answer to HTML
        answer_html = result.get('answer', 'No answer available')
        if result.get('llm_available'):
            try:
                answer_html = markdown.markdown(answer_html)
            except:
                pass  # Fallback to plain text
        else:
            # Simple HTML formatting for plain text
            answer_html = answer_html.replace('\n', '<br>')
        
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG Pipeline Result</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }}
        .container {{
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        .header {{
            border-bottom: 3px solid #007acc;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            color: #007acc;
            margin: 0;
        }}
        .timestamp {{
            color: #666;
            font-size: 0.9em;
        }}
        .section {{
            margin: 25px 0;
        }}
        .section h2 {{
            color: #333;
            border-left: 4px solid #007acc;
            padding-left: 15px;
            margin-bottom: 15px;
        }}
        .query-box {{
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            font-style: italic;
        }}
        .answer-box {{
            background: #fff;
            border: 1px solid #007acc;
            border-radius: 5px;
            padding: 20px;
            margin: 15px 0;
        }}
        .metadata {{
            background: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
        }}
        .metadata-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }}
        .metadata-item {{
            padding: 8px;
            background: white;
            border-radius: 3px;
            border-left: 3px solid #28a745;
        }}
        .search-result {{
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            background: #fafafa;
        }}
        .score {{
            color: #007acc;
            font-weight: bold;
        }}
        .footer {{
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }}
        code {{
            background: #f1f1f1;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}
        pre {{
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ RAG Pipeline Result</h1>
            <p class="timestamp">Generated: {timestamp}</p>
        </div>

        <div class="section">
            <h2>‚ùì Query</h2>
            <div class="query-box">
                {result.get('query', 'N/A')}
            </div>
        </div>

        <div class="section">
            <h2>üí° Answer</h2>
            <div class="answer-box">
                {answer_html}
            </div>
        </div>

        <div class="section">
            <h2>üìä Metadata</h2>
            <div class="metadata">
                <div class="metadata-grid">
                    <div class="metadata-item">
                        <strong>Confidence:</strong> {result.get('confidence', 0):.2f}
                    </div>
                    <div class="metadata-item">
                        <strong>LLM Model:</strong> {result.get('llm_model', 'N/A')}
                    </div>
                    <div class="metadata-item">
                        <strong>LLM Available:</strong> {'Yes' if result.get('llm_available') else 'No'}
                    </div>
                    <div class="metadata-item">
                        <strong>Tokens Used:</strong> {result.get('tokens_used', 'N/A')}
                    </div>
                    <div class="metadata-item">
                        <strong>Session ID:</strong> {result.get('session_id', 'N/A')[:8]}...
                    </div>
                    <div class="metadata-item">
                        <strong>Context Used:</strong> {result.get('context_used', 'N/A')} chars
                    </div>
                </div>
            </div>
        </div>
"""

        # Add sources if available
        sources = result.get('sources', [])
        if sources:
            html_content += """
        <div class="section">
            <h2>üîó Sources</h2>
            <ul>
"""
            for source in sources:
                source_url = source.get('source_url', 'Unknown')
                html_content += f'                <li><a href="{source_url}" target="_blank">{source_url}</a></li>\n'
            html_content += """            </ul>
        </div>
"""

        # Add search results if available
        search_results = result.get('search_results', [])
        if search_results:
            html_content += """
        <div class="section">
            <h2>üîç Search Results</h2>
"""
            for i, search_result in enumerate(search_results[:3], 1):  # Top 3
                score = search_result.get('similarity_score', 0)
                chunk = search_result.get('chunk', 'No content')[:200]
                html_content += f"""
            <div class="search-result">
                <h3>Result {i} <span class="score">(Score: {score:.3f})</span></h3>
                <p>{chunk}...</p>
            </div>
"""
            html_content += "        </div>\n"

        # Add context if available and no LLM
        if not result.get('llm_available') and result.get('context'):
            context = result.get('context', '')[:1000]
            html_content += f"""
        <div class="section">
            <h2>üìÑ Retrieved Context</h2>
            <pre>{context}...</pre>
        </div>
"""

        html_content += """
        <div class="footer">
            <p>Generated by RAG Pipeline with enhanced formatting</p>
        </div>
    </div>
</body>
</html>"""

        return html_content
    
    def save_both_formats(self, result: Dict, base_filename: Optional[str] = None) -> Dict[str, str]:
        """
        Save result in both Markdown and HTML formats.
        
        Args:
            result (Dict): RAG pipeline result
            base_filename (str, optional): Base filename (without extension)
        
        Returns:
            Dict[str, str]: Paths to saved files
        """
        if not base_filename:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            base_filename = f"rag_result_{timestamp}"
        
        md_path = self.save_result_as_markdown(result, f"{base_filename}.md")
        html_path = self.save_result_as_html(result, f"{base_filename}.html")
        
        return {
            "markdown": md_path,
            "html": html_path
        }
